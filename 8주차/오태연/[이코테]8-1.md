### 문제풀이 핵심아이디어 또는 새롭게 알게된 내용: 
    수학적 귀납법을 이용해 작성 -> f(n) 함수에서 n이 커지면 커질수록 수행시간이 급격하게 증가  
    -> 다이나믹 프로그래밍을 이용해 효율적으로 해결해야함!
    -> 다이나믹 프로그래밍 조건 모두 만족!
    1. 큰 문제를 작은 문제로 나눌 수 있다.
    2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다
    
### 코드의 시간복잡도와 그 이유:
    O(2^N)
    
    
### 주석이 가득 담긴 코드:
```python
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x-1) + fibo(x-2)

print(fivo)
```
